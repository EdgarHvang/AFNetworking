# Customise this file, documentation can be found here:
# https://github.com/KrauseFx/fastlane/tree/master/docs
# All available actions: https://github.com/KrauseFx/fastlane/blob/master/docs/Actions.md
# can also be listed using the `fastlane actions` command

# Change the syntax highlighting to Ruby
# All lines starting with a # are ignored when running `fastlane`

# By default, fastlane will send which actions are used
# No personal data is shared, more information on https://github.com/fastlane/enhancer
# Uncomment the following line to opt out
# opt_out_usage

# If you want to automatically update fastlane if a new version is available:
# update_fastlane

# This is the minimum version number required.
# Update this, if you use features of a newer version
fastlane_version "1.37.0"


before_all do
  # ENV["SLACK_URL"] = "https://hooks.slack.com/services/..."
end

lane :prepare_framework_release do |options|
  if !options[:version]
    raise "No version specified!".red
  end
  
  #Ensure the branch is clean
  if options[:allow_dirty_branch] != true
    ensure_git_status_clean
  end
  
  remote = options[:remote] ? options[:remote] : (ENV["DEPLOY_REMOTE"] ? ENV["DEPLOY_REMOTE"] : "origin")
  allowed_branch = options[:allow_branch] ? options[:allow_branch] : (ENV["DEPLOY_BRANCH"] ? ENV["DEPLOY_BRANCH"] : "master")
  
  #Ensure we are on the right branch
  ensure_git_branch(
    branch:allowed_branch
  )
  
  #Pull the latest to ensure we are up to date
  if options[:skip_git_pull] != true
    sh("git pull #{remote} #{allowed_branch}")
  end
  
  #Update the framework plist
  if options[:skip_plist_update] != true
    plist_path = options[:plist_path] ? options[:plist_path] : ENV["DEPLOY_PLIST_PATH"]
    set_info_plist_value(
      path: plist_path,
      key: "CFBundleVersion",
      value: options[:version]
    )
  end

  #Update the podspec
  if options[:skip_podspec_update] != true
    podspec = options[:podpsec] ? options[:podpsec] : ENV["DEPLOY_PODSPEC"]
    version_bump_podspec(
      path: podspec,
      version_number: options[:version]
    )
    
  end

  #Generate a Changelog
  if options[:skip_changelog] != true
    changelog = af_generate_github_milestone_changelog(
      milestone: options[:version]
    )
    
    af_insert_text_into_file(
      file_path: ENV["DEPLOY_CHANGELOG_PATH"],
      text: changelog[:header] + changelog[:changelog],
      insert_delimiter: ENV["DEPLOY_CHANGELOG_DELIMTER"]
    )
  end

  if prompt(text: "#{options[:version]} has been prepped for release. Would you like to commit, tag, and push #{options[:version]} to #{remote}?".green, boolean: true,ci_input:"y")
    
    # commit the branch
    git_commit(
      path: ".",
      message: "Preparing for the #{options[:version]} release"
    )

    #push the branch
    push_to_git_remote(
      remote: remote
    )
    
    # tag the repo
    add_git_tag(
      tag: "#{options[:version]}"
    )

    # push the tag
    if options [:skip_push_tags] != true
      af_push_git_tags_to_remote(
        remote: remote
      )
    end
    
    if !is_ci
      notification(
      title: "Release Preparation Complete",
      message: "The tag #{options[:version]} is now available"
      )
    end
    
  else 
    puts "OK. Make more additional changes and commit them, then run the `complete_release` lane"
  end
end

lane :complete_framework_release do |options|
  if options[:skip_ci_check] != true
    if !is_ci
      raise "#{lane_context[SharedValues::LANE_NAME]} should be run from a CI machine. If you want to override this, pass 'skip_ci_check:true'".red
    end
  end
  
  version = options[:version] ? options[:version] : last_git_tag.strip
  Helper.log.info "Using version #{version}"
  
  #Ensure clean branch
  if options[:allow_dirty_branch] != true
    ensure_git_status_clean
  end
  
  remote = options[:remote] ? options[:remote] : (ENV["DEPLOY_REMOTE"] ? ENV["DEPLOY_REMOTE"] : "origin")
  allowed_branch = options[:allow_branch] ? options[:allow_branch] : (ENV["DEPLOY_BRANCH"] ? ENV["DEPLOY_BRANCH"] : "master")
  
  #Ensure we are on the right branch
  ensure_git_branch(
    branch:allowed_branch
  )
  
  #Pull the latest to ensure we are up to date
  if options[:skip_git_pull] != true
    sh("git pull #{remote} #{allowed_branch}")
  end
  
  # Create a release
    #* Upload Notes
    #* Upload Carthage Asset  
  if options[:skip_github_release] != true
    af_generate_github_milestone_changelog(
          milestone: version
        )
    
    af_create_github_release(
        tag_name: version,
        name: version,
        body: lane_context[SharedValues::GITHUB_MILESTONE_CHANGELOG][:changelog],
        prerelease: true
      )
      
      # generate the carthage zip
      if options[:skip_carthage_framework] != true
        af_build_carthage_frameworks
        
        carthage_version = sh("carthage version").strip
        xcode_version = sh("xcodebuild -version").gsub!(/[\n]+/, " ").strip
        af_upload_asset_for_github_release(
          file_path:lane_context[SharedValues::CARTHAGE_FRAMEWORK],
          label:"Built by Carthage #{carthage_version} using #{xcode_version}"
        )
        
      end
  end
  
  #pod trunk push
  if options[:skip_pod_push] != true
    pod_push
    
    #pod spec lint
    af_pod_spec_lint
  end
end

lane :travis_commit do |options|
  if options[:configuration]
    configuration = options[:configuration]
  elsif ENV["AF_CONFIGURATION"]
    configuration = ENV["AF_CONFIGURATION"]
  else
    configuration = "Release"
  end
  
  test_framework(configuration: configuration)
  
  build_example(configuration: configuration)

  pod_spec_lint(
    quick:true
  )
end

desc "Runs all the tests"
lane :test_framework do |options|
  scan(
    configuration: options[:configuration]
  )
  
end

desc "Builds the example"
lane :build_example do |options|
  
  xcodebuild(
    workspace: ENV["EXAMPLE_WORKSPACE"],
    scheme: ENV["EXAMPLE_SCHEME"],
    build: true,
    destination: ENV["EXAMPLE_DESTINATION"],
    configuration: options[:configuration],
    build_settings: [["ONLY_ACTIVE_ARCH", "NO"]] 
  )
end

# You can define as many lanes as you want

after_all do |lane|
  # This block is called, only if the executed lane was successful
  
  # slack(
  #   message: "Successfully deployed new App Update."
  # )
end

error do |lane, exception|
  # slack(
  #   message: exception.message,
  #   success: false
  # )
end

# More information about multiple platforms in fastlane: https://github.com/KrauseFx/fastlane/blob/master/docs/Platforms.md
# All available actions: https://github.com/KrauseFx/fastlane/blob/master/docs/Actions.md
